---
title: "[ex50] 같은 모양 찾기 simple"
tags:
    - Study
    - Language
date: "2025-03-18"
thumbnail: "/assets/img/thumbnail/C.png"
bookmark: true
---
# 문제 설명
---
아래와 같이 모눈종이에 각각의 칸들이 칠해져 있는 그림이 있을 때 모눈종이에서 찾고 싶은 패턴의 모양이 몇 개가 있는지를 검사하려고 한다. 이 때, 찾고자 하는 모눈종이의 크기 M(0≤M≤100)과 패턴의 크기 P(0≤P≤100)은 주어진다.

![ex](<../../../../assets/img/C Language/ex50_t.png>)

찾고자 하는 패턴의 모양은 회색과 흰색으로 칠해지고, 패턴은 같은 모양만 찾으면 된다. 또한 회색으로 칠해진 칸은 패턴 매치 검사 시 반복되어 사용될 수 있다.

```c
#include <stdio.h>
 
int main(void)
{
      // 여기서부터 작성
 
      return 0;
} 
```

# 입력 설명
---

```
첫 번째 줄에는 모눈종이이의 크기 M(0≤M≤100)이 주어진다.
두 번째 줄부터 M 줄까지는 모눈종이에 그린 그림을 칠한 칸은 1로, 칠하지 않은 칸은 0으로 모눈종이의 줄 별로 입력한다.
다음 줄에는 패턴의 크기 P(0≤P≤100)가 주어진다. 다음 줄부터 P개의 줄에 걸쳐 찾고 싶은 패턴의 모양이 주어진다. 모양이 있는 부분만 1 로 입력하고 나머지는 0으로 처리한다.
```

# 출력 설명
---

```
출력은 찾고 싶은 패턴의 모양이 모눈종이에 그린 그림에 몇 개가 있는지 그 개수를 출력한다.
```

# 입력 예시
---
```
10
0000000001
1110000000
0000001000
0000101000
1111111111
0000101000
0000001000
0000000000
1110000000
0000000001
3
100
111
100
```

# 출력 예시
---

```
1
```

# 정답 코드
---

```c
#include <stdio.h>

int maa[110][110], b[110][110];
int N,P;

int pattern(int k, int m)
{
	int i, j; 	
	int sol = 0;
	
	for (i = 0; i < N ; i++)
	{
		for (j = 0; j < N ; j++)
		{
			if (maa[i + k][j + m] == b[i][j])
			{
				sol++;
			}	
		}
	}

	return sol;
}

int main(void)
{
	int i, j;

	scanf("%d", &P);

	for (i = 0; i < P; i++)
	{
		for (j = 0; j < P; j++)
		{
			scanf("%1d", &maa[i][j]);
		}
	}
	
	scanf("%d", &N);
	
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			scanf("%1d", &b[i][j]);
		}
	}
	
	int Num = 0;
	
	for (i = 0; i <= P - N; i++)
	{
		for (j = 0; j <= P - N; j++)
		{
			if (pattern(i, j) == N*N)
			{
				Num++;	
			}
		}
	}	

	printf("%d ", Num);

	return 0;
}
```

# 메모
---
> printf 내부의 **\n** 습관화 필요