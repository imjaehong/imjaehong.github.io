---
title: "2025-08-07"
tags:
    - Study
    - Language
date: "2025-08-07"
thumbnail: "/assets/img/thumbnail/SystemVerilog.png"
bookmark: true
---

# Class Notes
---
> **D-flip flop , Latch 차이**
> - 메모리 기능의 유무 → 둘 다 메모리 기능이 있지만, 동작 방식에 차이가 있음
> - Latch: 입력 신호가 활성화된 동안 값을 계속 반영함 (레벨 민감)
> - D Flip-Flop: 클록 상승/하강 에지에서만 값을 반영 (엣지 트리거)

> **조합회로 (Combinational Circuit)**
> - 현재 입력에 의해서만 출력이 결정됨
> - 과거 입력이나 상태와는 무관
> - 예시: AND, OR, MUX, Decoder 등

> **순차회로 (Sequential Circuit)**
> - 클록 신호에 따라 동작 (동기식 설계)
> - 출력은 현재 입력 + 이전 상태에 의존
> - 예시: D Flip-Flop, 레지스터, FSM 등

> **SR Latch**
> - S=0, R=0 → Q=유지, Q′=유지 → 정상 상태 (Hold)
> - S=0, R=1 → Q=0, Q′=1 → Reset 동작
> - S=1, R=0 → Q=1, Q′=0 → Set 동작
> - S=1, R=1 → Q=0, Q′=0 → 금지 상태 (Invalid)

> **D Latch**
> - D=0, S=0, R=1 → Reset
> - D=1, S=1, R=0 → Set

> **Gated D Latch**
> - Gate=0, D=x, Q=유지, Q'=유지 → Hold 상태
> - Gate=1, D=0, Q=0, Q'=1 → Reset 동작
> - Gate=1, D=1, Q=1, Q'=0 → Set 동작

> **D-Filp Flop**
> - D Flip-Flop은 Master-Slave 구조의 두 개의 D-Latch로 구성
>  - Master: 클록이 0일 때 입력 값을 저장
>  - Slave: 클록이 1일 때 Master의 값을 출력에 전달
>  - 따라서 클록의 상승/하강 엣지에만 출력이 바뀜 (엣지 트리거)

> **Metastability**
> - 클록 엣지 시점에 입력(D)이 변할 경우, 출력(Q)이 일정 시간 동안 정의되지 않은 상태에 머무를 수 있음
>  - Setup Time: 클록 엣지 이전 일정 시간 동안 D 입력이 안정적으로 유지되어야 함
>  - Hold Time: 클록 엣지 이후 일정 시간 동안도 D 입력이 유지되어야 함

> **Metastability 방지 방법 – 동기화 회로 (Synchronizer)**
> - 외부 신호(비동기 입력 등)는 클록 도메인에 따라 metastable 위험이 있음
> - D Flip-Flop을 2개 이상 직렬로 연결
>  - 첫 번째 F/F는 신호를 잠시 받아들이고
>  - 두 번째 F/F는 클록에 동기화된 안정된 출력을 생성

> **Glitch (순간 출력 오류)**
> - 조합 회로에서 입력이 동시에 변할 때, 내부 게이트의 전파 지연 차이로 인해 일시적인 잘못된 출력이 발생할 수 있음
> - 클록 엣지 직전까지 출력이 안정되지 않으면 시스템 오동작 가능성 존재

![alt text](../../assets/img/Noh_Jinho/250807_1.png)

> **Propagation Delay (전파 지연)**
> - 입력 변화 이후 출력이 안정될 때까지의 시간 지연
> - 조합 회로가 복잡하거나 깊이가 깊을수록 지연 시간이 길어짐
> - 예: FFT filter 설계 시 곱셈 연산은 시간이 오래 걸리므로, 중간에 레지스터를 삽입하여 처리

> **Pipeline 처리**
> - 연산 중간에 레지스터를 추가하여 연산 단계를 여러 클록 사이클로 분할
> - 조합 논리의 길이를 줄여 glitch를 방지할 수 있음
> - 복잡한 연산을 분할 처리해 클록 타이밍 여유 확보 가능
> - 한 클럭 내에 연산이 끝나도록 회로를 구성하면 안정적인 시스템 설계 가능


### button_detector
```verilog
`timescale 1ns / 1ps

module button_detector (
    input  logic clk,
    input  logic reset,
    input  logic in_button,
    output logic out_button
);
    logic debounce;
    logic [7:0] sh_reg;

    shift_register U_Shift_Register (
        .clk     (clk),
        .reset   (reset),
        .in_data (in_button),
        .out_data(sh_reg)
    );
    assign debounce   = &sh_reg;
    assign out_button = debounce;

endmodule

module shift_register (
    input  logic       clk,
    input  logic       reset,
    input  logic       in_data,
    output logic [7:0] out_data
);
    always_ff @(posedge clk, posedge reset) begin
        if (reset) begin
            out_data <= 0;
        end else begin
            out_data <= {in_data, out_data[7:1]};  // right shift
            // out_data <= {out_data[6:0], in_data};  // left shift
        end
    end

endmodule
```

### button_detector_tb
```verilog
`timescale 1ns / 1ps

class transaction;
    rand bit button;

    function bit run_random();
        return button;
    endfunction  // new()
endclass  // transaction

module button_detector_tb ();

    logic clk;
    logic reset;
    logic in_button;
    logic out_button;

    transaction tr;  // make class instance

    button_detector dut (
        .clk(clk),
        .reset(reset),
        .in_button(in_button),
        .out_button(out_button)
    );

    always #5 clk = ~clk;

    initial begin
        clk = 0;
        reset = 1;
        tr = new();
        #10;
        reset = 0;
        in_button = 0;
        #20;

        in_button = 1;
        for (int i = 0; i < 60; i++) begin
            tr.randomize();
            in_button = tr.run_random();
            #1;
        end
        in_button = 1;
        #100;
        $finish;
    end

endmodule
```