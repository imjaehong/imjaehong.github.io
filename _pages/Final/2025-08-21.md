---
title: "2025-08-21"
tags:
    - Study
    - System Verilog
date: "2025-08-21"
thumbnail: "/assets/img/thumbnail/SystemVerilog.png"
bookmark: true
---

# Multi Cycle 
---
### single cycle 흐름
![alt text](../../assets/img/final/250821/1.png)

PC -(주소)-> ROM -(명령어)-> RegFile, ControlUnit(Decoding->SignalOut) -> ALU -> RAM -> Regfile

가장 긴 Path의 경우, 1 클럭동안 ALU 입력신호와 ControlUnit 에서 내보내는 신호를 같이 받아서 RAM 으로 가서 메모리 access 후 RAM 에서 나온 결과가 RegFile 에 들어감. -> 클럭 길이가 너무 길다

![alt text](../../assets/img/final/250821/2.png)

조합회로가 5개 있다고 가정하고 각 회로마다 10ns 시간이 걸린다면 클럭을 아무리 줄여도 최도한 50ns 이상 되어야한다.

![alt text](../../assets/img/final/250821/3.png)

중간에 FF 을 둔다고 가정하고 이는 1ns 시간이 걸린다면 전체를 통과하는데 걸리는 시간이 56ns + a 필요

![alt text](../../assets/img/final/250821/4.png)

Fetch : 명령어를 빼내는 동작 (ROM 입출력 + PC 출력)
Decode : opcode 분석 (ImmExtend 출력 + ControlUnit 입출력)
Excute : 실행, 연산 (ALU 입출력 + PC 입력부 gate 들과 mux, Jump 판단)
MemAccess : RAM 입력 (ALU 출력 + RAM 입력)
WriteBack : RAM 출력 (RAM 출력 + RegFile 입력)

![alt text](../../assets/img/final/250821/5.png)

R-Type : 34 + a ns 
S-Type : 45 + a ns
L-Type : 56 + a ns
=> Single Cycle 보다 효율이 약간 더 올라감
주의점 : Fetch 구간에서 동작까지 다음 명령어가 나오면 이건 Pipeline 구조, Fetch 구간에서 동작까지 다음 명령어가 나오지 않으면 Multi Cycle 구조

![alt text](../../assets/img/final/250821/6.png)

ControlUnit 에 구간별로 FSM 필요
RV32I-V 해체 작업 필요

![alt text](../../assets/img/final/250821/7.png)

Fetch 구간 : PC를 좀 빼서 PCEn 신호 필요
Decode 구간 : RegFile 출력, ImmExtend 출력 Reg 추가
Excute 구간 : 메모리 Access 하기 전, PC로 가기 전 Reg 추가
MemAccess 구간 : RAM 입력부분 Reg 추가
WriteBack 구간 : RAM 출력부분 Reg 추가





