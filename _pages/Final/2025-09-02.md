---
title: "2025-09-02"
tags:
    - Study
    - System Verilog
date: "2025-09-02"
thumbnail: "/assets/img/thumbnail/SystemVerilog.png"
bookmark: true
---

# UVM 검증
---
System Verilog : 검증에 대한 표준이 되어가고 있음
UVM : 검증 Framework, System Verilog 로 설계

| | Verilog | System Verilog |
|:--:|:--:|:--:|
| OOP(객체지향) | X<br>(Class X) | O<br>(Class 문법 사용) |
| DataType | H/W 중심 DataType | S/W 중심 DataType<br>(S/W 기능 추가) |
| interface | X | SW <=> HW 연결<br>검증용 SW <=> DUT HW |
| randomization | random<br>제한적기능 | 각 변수에 random 생성<br>constraint 기능<br>corner case 생성 |

### System Verilog Data Type
- 4-state(벡터) : 0, 1, x, z -> logic, reg, wire
- 2-state(벡터) : 0, 1 -> bit
- 4-state(정수) : integer(32bit)
- 2-state(정수) : byte(8), shortint(16), int(32), longint(64)

### 배열 (SW 자료형)
![alt text](../../assets/img/final/250902/1.png)

**고정 길이 배열 (fixed-size array, static array)**
- 선언 시 크기가 고정되고 runtime에 크기 변경불가
- 예:
    ```verilog
    bit  arr[8];     // 8개의 bit 원소
    byte arr2[4];    // 4개의 byte 원소
    int  arr3[16];   // 16개의 int 원소
    ```

**동적 배열 (dynamic array)**
- 선언만 해두고, runtime에 new를 통해 크기 결정
- 필요 시 크기 변경 가능 (new[] 재호출)
- 예:
    ```verilog
    bit  arr[];  
    arr = new[8];    // 크기 8로 할당

    int  arr2[];  
    arr2 = new[16];  // 크기 16으로 재할당 가능
    ```

- delete() 사용 시 메모리 해제 가능

> 고정 길이 배열은 하드웨어에 가깝고 (Verilog 스타일), 동적 배열은 소프트웨어적 성격 (테스트벤치, 검증 환경)에서 주로 활용

### Queue Type (FIFO)
- 크기가 가변적이고, 앞뒤로 push/pop 가능
- 선언:
    ```verilog
    bit que[$];   // bit 타입 queue
    int que2[$];  // int 타입 queue
    ```

- 주요 메서드:
    ```verilog
    que.push_back(1);   // 뒤에 삽입
    que.push_front(4);  // 앞에 삽입
    que.pop_front();    // 앞에서 꺼냄
    que.pop_back();     // 뒤에서 꺼냄
    ```

- 그 외 자주 쓰이는 메서드:
    ```verilog
    que.size()             // 현재 크기 반환
    que.delete()           // 모든 원소 삭제
    que.insert(idx, value) // 특정 위치에 삽입
    que.delete(idx)        // 특정 위치 원소 삭제
    ```

> Queue는 UVM testbench에서 transaction 저장/전달, mailbox 대체 용도 등으로 자주 활용


### Test Bench, UVM 구조의 System Verilog 검증 Test Bench
![alt text](../../assets/img/final/250902/2.png)

- generator(입력 data 생성) : stimulus 생성 (transaction 단위)
- driver(전달) : transaction을 핀 레벨 신호로 변환해 DUT 입력에 적용
- monitor(감시) : DUT 입출력을 트랜잭션으로 변환해 전달
- scoreboard(pass/fail 판단) : 예측값과 DUT 출력을 비교, 검증 수행
- interface(연결) : 신호 묶음과 방향 제어, driver/monitor와 DUT 간 연결
- DUT(HW) : testbench가 자극을 주고, 응답을 평가하는 대상

### 실습
class : generator, driver 만들고 감싸는 env 만들고 interface, dut 만들면 됨

데이터 묶음을 전달하기 위해 어떻게? 구조체를 지원하지만 class 를 쓰는 게 일반적임
transaction : 데이터 묶음

C언어에서 구조체는 변수만 넣을 수 있음
Class는 변수+함수 넣을 수 있음 (캡슐화)

```verilog
module tb_adder ();
    environment env; // Class
    adder_intf adder_if (); // HW(메모리가 아님)

    adder dut ( // HW
        .a(adder_if.a),
        .b(adder_if.b),
        .result(adder_if.result)
    );

    initial begin
        env = new(adder_if); // new(virtual adder_intf adder_if(실제 HW정보 입력) = adder_if) 가명에 연결한 느낌
        env.run();
    end
endmodule
```

```verilog
class environment;
    generator gen;
    driver drv;
    mailbox #(transaction) gen2drv_mbox;

    function new(virtual adder_intf adder_if); // 위의 new를 콜함. virtual(HW를 SW적으로 연결)는 가상인터페이스(HW를 그냥 전달하면 안됨, SW처럼 생각하자)
        gen2drv_mbox = new(); // 정보를 주고
        gen = new(gen2drv_mbox); // 정보를 주고
        drv = new(gen2drv_mbox, adder_if); // 정보를 주고
    endfunction

    task run();
        fork
            gen.run(20);
            drv.run();
        join_any
        #(10 * 10) $finish;
    endtask
endclass
```

```verilog
class driver;
    transaction tr;
    virtual adder_intf adder_if;
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox#(transaction) gen2drv_mbox, // 주소
                 virtual adder_intf adder_if); // HW정보
        this.gen2drv_mbox = gen2drv_mbox;
        this.adder_if = adder_if;
    endfunction

    task run();
        forever begin
            gen2drv_mbox.get(tr);
            adder_if.a = tr.a;
            adder_if.b = tr.b;
        end
    endtask
endclass
```

```verilog
class generator;
    transaction tr;  // handler
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox#(transaction) gen2drv_mbox);
        this.gen2drv_mbox = gen2drv_mbox;
    endfunction

    task run(int run_count);
        repeat (run_count) begin
            tr = new(); // make instance. 실체화 시킨다. heap memory에 class 자료형을 만든다.
            tr.randomize();
            gen2drv_mbox.put(tr); // 해당 인터페이스의 주소값(tr)을 넣어줌
            #10;
        end
    endtask
endclass
```

---

```verilog
class environment;
    generator gen;
    driver drv;
    mailbox #(transaction) gen2drv_mbox;

    function new(virtual adder_intf adder_if);
        gen2drv_mbox = new();
        gen = new(gen2drv_mbox);
        drv = new(gen2drv_mbox, adder_if);
    endfunction

    task run();
        fork // 멀티 프로세서 실행
            gen.run(20); // 독집적으로 돌아감
            drv.run(); // 독집적으로 돌아감
        join_any
        #(10 * 10) $finish;
    endtask
endclass
```






