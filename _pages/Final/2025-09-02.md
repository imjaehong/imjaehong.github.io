---
title: "2025-09-02"
tags:
    - Study
    - System Verilog
date: "2025-09-02"
thumbnail: "/assets/img/thumbnail/SystemVerilog.png"
bookmark: true
---

# UVM 검증
---
System Verilog : 검증에 대한 표준이 되어가고 있음
UVM : 검증 Framework, System Verilog 로 설계

| | Verilog | System Verilog |
|:--:|:--:|:--:|
| OOP(객체지향) | X<br>(Class X) | O<br>(Class 문법 사용) |
| DataType | H/W 중심 DataType | S/W 중심 DataType<br>(S/W 기능 추가) |
| interface | X | SW <=> HW 연결<br>검증용 SW <=> DUT HW |
| randomization | random<br>제한적기능 | 각 변수에 random 생성<br>constraint 기능<br>corner case 생성 |

### System Verilog Data Type
4-state(벡터) : 0, 1, x, z -> logic, reg, wire
2-state(벡터) : 0, 1 -> bit
4-state(정수) : integer(32bit)
2-state(정수) : byte(8), shortint(16), int(32), longint(64)

### 배열 (SW 자료형)
![alt text](../../assets/img/final/250902/1.png)

고정 길이 배열 (fixed-size array, static array)
- 선언 시 크기가 고정되고 runtime에 크기 변경불가
- 예:
    ```verilog
    bit  arr[8];     // 8개의 bit 원소
    byte arr2[4];    // 4개의 byte 원소
    int  arr3[16];   // 16개의 int 원소
    ```

동적 배열 (dynamic array)
- 선언만 해두고, runtime에 new를 통해 크기 결정
- 필요 시 크기 변경 가능 (new[] 재호출)
- 예:
    ```verilog
    bit  arr[];  
    arr = new[8];    // 크기 8로 할당

    int  arr2[];  
    arr2 = new[16];  // 크기 16으로 재할당 가능
    ```

- delete() 사용 시 메모리 해제 가능

> 고정 길이 배열은 하드웨어에 가깝고 (Verilog 스타일), 동적 배열은 소프트웨어적 성격 (테스트벤치, 검증 환경)에서 주로 활용

### Queue Type (FIFO)
- 크기가 가변적이고, 앞뒤로 push/pop 가능
- 선언:
    ```verilog
    bit que[$];   // bit 타입 queue
    int que2[$];  // int 타입 queue
    ```

- 주요 메서드:
    ```verilog
    que.push_back(1);   // 뒤에 삽입
    que.push_front(4);  // 앞에 삽입
    que.pop_front();    // 앞에서 꺼냄
    que.pop_back();     // 뒤에서 꺼냄
    ```

- 그 외 자주 쓰이는 메서드:
    ```verilog
    que.size()             // 현재 크기 반환
    que.delete()           // 모든 원소 삭제
    que.insert(idx, value) // 특정 위치에 삽입
    que.delete(idx)        // 특정 위치 원소 삭제
    ```

> Queue는 UVM testbench에서 transaction 저장/전달, mailbox 대체 용도 등으로 자주 활용


### Test Bench, UVM 구조의 System Verilog 검증 Test Bench
![alt text](../../assets/img/final/250902/2.png)

generator(입력 data 생성) : 입력 데이터(stimulus) 생성
driver(전달) : 해당 signal에 맞워서 입력 데이터(stimulus)를 받아서 interface 로 넘겨줌
monitor(감시) : DUT의 입출력을 감시하여 값을 scoreboard 로 전달
scoreboard(pass/fail 판단) : 값을 받아서 
DUT(HW) : 입력을 받아서 출력함
interface(연결) : HW 값을 SW 값으로 변경시켜줌



